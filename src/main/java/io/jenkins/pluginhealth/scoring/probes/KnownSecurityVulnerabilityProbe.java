package io.jenkins.pluginhealth.scoring.probes;

import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.jenkins.pluginhealth.scoring.model.Plugin;
import io.jenkins.pluginhealth.scoring.model.ProbeResult;
import io.jenkins.pluginhealth.scoring.model.updatecenter.SecurityWarning;

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(value = KnownSecurityVulnerabilityProbe.ORDER)
public class KnownSecurityVulnerabilityProbe extends Probe {
    public static final int ORDER = UpForAdoptionProbe.ORDER + 1;

    @Override
    protected ProbeResult doApply(Plugin plugin, ProbeContext context) {
        final List<SecurityWarning> warnings = context.getUpdateCenter().warnings();
        final Optional<SecurityWarning> warning = warnings.stream()
            .filter(w -> w.name().equals(plugin.getName()))
            .filter(w -> w.versions().stream().anyMatch(securityWarningVersion -> {
                if (securityWarningVersion.lastVersion() != null) {
                    return plugin.getVersion().isOlderThanOrEqualTo(securityWarningVersion.lastVersion());
                }
                final Pattern pattern = Pattern.compile(securityWarningVersion.pattern());
                final Matcher matcher = pattern.matcher(plugin.getVersion().toString());
                return matcher.find();
            }))
            .findAny();

        return warning
            .map(w -> ProbeResult.failure(key(), w.id()))
            .orElseGet(() -> ProbeResult.success(key(), "Plugin is OK"));
    }

    @Override
    public String key() {
        return "security";
    }

    @Override
    public String getDescription() {
        return "Detects if a given plugin has a public security vulnerability advertised in a security advisory.";
    }
}
