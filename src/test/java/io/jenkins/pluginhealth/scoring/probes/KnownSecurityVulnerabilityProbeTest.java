package io.jenkins.pluginhealth.scoring.probes;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import java.time.ZonedDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import io.jenkins.pluginhealth.scoring.model.ProbeResult;
import io.jenkins.pluginhealth.scoring.model.ResultStatus;
import io.jenkins.pluginhealth.scoring.model.updatecenter.Plugin;
import io.jenkins.pluginhealth.scoring.model.updatecenter.SecurityWarning;
import io.jenkins.pluginhealth.scoring.model.updatecenter.SecurityWarningVersion;
import io.jenkins.pluginhealth.scoring.model.updatecenter.UpdateCenter;

import hudson.util.VersionNumber;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class KnownSecurityVulnerabilityProbeTest {
    @Test
    public void shouldUseKeySecurity() {
        final KnownSecurityVulnerabilityProbe probe = spy(KnownSecurityVulnerabilityProbe.class);
        assertThat(probe.key()).isEqualTo("security");
    }

    @Test
    public void shouldNotRequireNewRelease() {
        final KnownSecurityVulnerabilityProbe probe = spy(KnownSecurityVulnerabilityProbe.class);
        assertThat(probe.requiresRelease()).isFalse();
    }

    @Test
    public void shouldBeOKWithNoSecurityWarning() {
        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                Collections.emptyList()
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.SUCCESS);
    }

    @Test
    public void shouldBeOKWithWarningOnDifferentPlugin() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.0");
        final var pluginInUC = new Plugin(pluginName, pluginVersion, "scm", ZonedDateTime.now().minusHours(1), List.of());
        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Map.of(pluginName, pluginInUC),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning("SECURITY-1", "wiz", List.of(new SecurityWarningVersion(null, ".*")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.SUCCESS);
    }

    @Test
    public void shouldBeOKWithWarningOnOlderVersion() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.1");

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning("SECURITY-1", pluginName, List.of(
                        new SecurityWarningVersion(new VersionNumber("1.0"), "0\\.*")
                    ))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.SUCCESS);
    }

    @Test
    public void shouldNotBeOKWithWarningOnCurrentVersion() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.1");
        final String warningId = "SECURITY-1";

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning(warningId, pluginName, List.of(new SecurityWarningVersion(pluginVersion, "1.0")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.FAILURE);
        assertThat(result.message()).isEqualTo(warningId);
    }

    @Test
    public void shouldNotBeOKWithWarningWithoutLastVersion() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.1");
        final String warningId = "SECURITY-1";

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning(warningId, pluginName, List.of(new SecurityWarningVersion(null, ".*")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.FAILURE);
        assertThat(result.message()).isEqualTo(warningId);
    }

    @Test
    public void shouldNotBeOKWithMultipleWarningsWithoutLastVersion() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.1");
        final String warningId1 = "SECURITY-1";
        final String warningId2 = "SECURITY-2";

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning(warningId1, pluginName, List.of(new SecurityWarningVersion(null, ".*"))),
                    new SecurityWarning(warningId2, pluginName, List.of(new SecurityWarningVersion(null, ".*")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.FAILURE);
        assertThat(result.message()).isEqualTo("%s, %s".formatted(warningId1, warningId2));
    }

    @Test
    public void shouldNotBeOKWithWarningWithoutLastVersionAndOneResolved() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("1.2");
        final String warningId1 = "SECURITY-1";
        final String warningId2 = "SECURITY-1";

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning(warningId1, pluginName, List.of(new SecurityWarningVersion(null, ".*"))),
                    new SecurityWarning(warningId2, pluginName, List.of(new SecurityWarningVersion(new VersionNumber("1.1"), ".*")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.FAILURE);
        assertThat(result.message()).isEqualTo(warningId1);
    }

    @Test
    public void shouldBeOKWithWarningWithoutLastVersionButOutOfPattern() {
        final String pluginName = "foo-bar";
        final VersionNumber pluginVersion = new VersionNumber("2.0");

        final var plugin = mock(io.jenkins.pluginhealth.scoring.model.Plugin.class);
        final ProbeContext ctx = mock(ProbeContext.class);
        final KnownSecurityVulnerabilityProbe probe = new KnownSecurityVulnerabilityProbe();

        when(plugin.getName()).thenReturn(pluginName);
        when(plugin.getVersion()).thenReturn(pluginVersion);
        when(ctx.getUpdateCenter()).thenReturn(
            new UpdateCenter(
                Collections.emptyMap(),
                Collections.emptyMap(),
                List.of(
                    new SecurityWarning("SECURITY-1", pluginName, List.of(new SecurityWarningVersion(null, "[0-1]\\..*")))
                )
            )
        );

        final ProbeResult result = probe.apply(plugin, ctx);

        assertThat(result.status()).isEqualTo(ResultStatus.SUCCESS);
    }
}
